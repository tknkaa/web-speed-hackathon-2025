# syntax=docker/dockerfile:1
# 
# SIMPLE DOCKERFILE - Alternative approach
# Use this if the main Dockerfile continues to have issues
#

# Stage 1: Build stage
FROM node:22.14.0-slim AS builder

# Install build dependencies
RUN apt-get update && apt-get install -y \
    python3 \
    make \
    g++ \
    && rm -rf /var/lib/apt/lists/*

# Enable corepack and install pnpm
RUN corepack enable && corepack prepare pnpm@9.14.2 --activate

WORKDIR /app

# Copy everything (simpler, less prone to errors)
COPY . .

# Install all dependencies
RUN pnpm install --frozen-lockfile

# Build the client application
RUN pnpm run build

# Generate and seed the SQLite database (required at runtime)
WORKDIR /app/workspaces/server
RUN npx drizzle-kit generate && npx drizzle-kit push
RUN npx tsx ./tools/seed.ts
WORKDIR /app

# Clean up development dependencies and unnecessary files
RUN rm -rf ./node_modules ./workspaces/*/.wireit ./workspaces/test && \
    pnpm install --prod --frozen-lockfile

# Stage 2: Production stage
FROM node:22.14.0-slim AS production

# Enable corepack and install pnpm
RUN corepack enable && corepack prepare pnpm@9.14.2 --activate

WORKDIR /app

# Copy built application from builder
COPY --from=builder /app ./

# Set environment variables
ENV NODE_ENV=production
ENV PORT=8000
ENV API_BASE_URL=http://localhost:8000/api

# Expose the application port
EXPOSE 8000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=10s --retries=3 \
    CMD node -e "require('http').get('http://localhost:8000/', (r) => {process.exit(r.statusCode < 500 ? 0 : 1)})"

# Start the application
CMD ["pnpm", "run", "heroku-start"]
